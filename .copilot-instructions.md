# AI Development Guidelines for HOPE

## Project Context

You are helping develop HOPE, a 2D puzzle platformer where the player controls a pole-wielding robot using only controller joysticks (no buttons). The game features arcade-style movement with fighting game-inspired motion inputs. This document provides specific guidance for AI assistants working on this project.

## Core Principles

### 1. Stick-Only Input Constraint

- **NEVER** implement button inputs or keyboard controls
- **ALWAYS** use only left stick, right stick, and right stick click
- **VERIFY** that all interactions can be performed with these inputs
- **REJECT** any suggestions that require additional inputs

### 2. Dual-Circle Input Design

- **IMPLEMENT** magnitude-based input detection (inner 0-70%, outer 70-97%)
- **ENSURE** input difficulty matches mechanical effort required
- **PROVIDE** clear visual feedback for circle transitions
- **AVOID** accidental outer circle activation with generous thresholds

### 3. Accessibility Through Design

- **PROVIDE** visual feedback for all audio cues
- **ENSURE** colorblind accessibility in all visual elements
- **IMPLEMENT** controller rumble for circle transitions and move feedback
- **DESIGN** generous input windows for complex motion patterns

## Development Approach

### Test-Driven Development

1. **Write tests first** for each new mechanic
2. **Implement minimum viable version** to pass tests
3. **Refactor and polish** while maintaining test coverage
4. **Add integration tests** for dual-circle input combinations

### Code Organization

```
scripts/
├── player/
│   ├── HopeController.gd      # Main player controller
│   ├── DualCircleInput.gd     # Magnitude-based input detection
│   ├── MotionDetector.gd      # Pattern recognition system
│   └── MoveSystem.gd          # Special move execution
├── enemies/
│   ├── BaseEnemy.gd           # Shared enemy behaviors
│   ├── PatrolBot.gd           # Basic enemy type
│   └── SentryBot.gd           # Ranged enemy type
├── environment/
│   ├── MovingPlatform.gd      # Dynamic platforms
│   └── InteractiveSwitch.gd   # Environmental interactions
├── story/
│   ├── CutsceneManager.gd     # Move introduction cutscenes
│   └── TrainingRoom.gd        # Practice areas for new moves
└── systems/
    ├── CameraController.gd    # Right stick camera control
    ├── AudioManager.gd        # Dynamic audio system
    └── GameManager.gd         # Linear progression system
```

### Scene Structure

```
Main.tscn
├── Player/
│   ├── Hope (CharacterBody2D)
│   ├── DualCircleDetector (Node)
│   ├── MotionBuffer (Node)
│   └── MoveAnimator (AnimationPlayer)
├── Environment/
│   ├── StaticGeometry
│   ├── MovingPlatforms
│   └── InteractiveElements
├── Enemies/
│   └── [Enemy instances]
├── Story/
│   ├── CutscenePlayer
│   └── TrainingRoom
├── UI/
│   ├── MoveIndicator
│   └── InteractionPrompts
└── Systems/
    ├── CameraRig
    ├── AudioSources
    └── ProgressionManager
```

## Implementation Guidelines

### Dual-Circle Input System
```gdscript
# Example structure for DualCircleInput.gd
extends Node
class_name DualCircleInput

@export var inner_circle_max: float = 0.7
@export var outer_circle_min: float = 0.7
@export var outer_circle_max: float = 0.97
@export var dead_zone: float = 0.1

enum InputCircle {
    NONE,
    INNER,
    OUTER
}

var current_circle: InputCircle = InputCircle.NONE
var circle_transition_buffer: Array[InputCircle] = []

func process_stick_input(stick_input: Vector2) -> Dictionary:
    var magnitude = stick_input.length()
    var direction = stick_input.normalized()
    
    var circle = _determine_input_circle(magnitude)
    var result = {
        "circle": circle,
        "direction": direction,
        "magnitude": magnitude,
        "is_transition": _check_circle_transition(circle)
    }
    
    _update_circle_history(circle)
    return result

func _determine_input_circle(magnitude: float) -> InputCircle:
    if magnitude < dead_zone:
        return InputCircle.NONE
    elif magnitude <= inner_circle_max:
        return InputCircle.INNER
    elif magnitude >= outer_circle_min and magnitude <= outer_circle_max:
        return InputCircle.OUTER
    else:
        return InputCircle.NONE  # Beyond max range

func _check_circle_transition(new_circle: InputCircle) -> bool:
    return current_circle != new_circle and new_circle != InputCircle.NONE
```

### Player Controller
```gdscript
# Example structure for HopeController.gd
extends CharacterBody2D

@export var move_speed: float = 120.0
@export var motion_buffer_time: float = 0.8
@export var input_tolerance: float = 22.5  # degrees

var dual_circle_input: DualCircleInput
var motion_detector: MotionDetector
var current_move: String = ""
var move_cooldown: float = 0.0

func _ready():
    dual_circle_input = DualCircleInput.new()
    motion_detector = MotionDetector.new()
    _setup_move_patterns()

func _physics_process(delta):
    handle_dual_circle_input()
    update_motion_detection(delta)
    execute_moves(delta)
    apply_movement(delta)

func handle_dual_circle_input():
    var left_stick = Vector2(
        Input.get_joy_axis(0, JOY_AXIS_LEFT_X),
        Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)
    )
    
    var input_data = dual_circle_input.process_stick_input(left_stick)
    
    # Handle basic movement (inner circle)
    if input_data.circle == DualCircleInput.InputCircle.INNER:
        _handle_basic_movement(input_data.direction, input_data.magnitude)
    
    # Handle complex motions (outer circle)
    elif input_data.circle == DualCircleInput.InputCircle.OUTER:
        motion_detector.add_input(input_data.direction, input_data.magnitude)
    
    # Handle circle transitions
    if input_data.is_transition:
        _handle_circle_transition(input_data)
```

### Motion Detection System
```gdscript
# Example motion detection for dual-circle patterns
func detect_motion_pattern(buffer: Array[MotionInput]) -> String:
    # Stand Up: Full outer circle + inner up
    if _matches_stand_up_pattern(buffer):
        return "stand_up"
    
    # Pole Vault: Outer circle ↓↘→
    if _matches_outer_pattern(buffer, [Vector2.DOWN, Vector2(1, 1), Vector2.RIGHT]):
        return "pole_vault"
    
    # Spinning Swipe: Outer →↓↘ + 270° rotation
    if _matches_spinning_pattern(buffer):
        return "spinning_swipe"
    
    return ""

func _matches_stand_up_pattern(buffer: Array[MotionInput]) -> bool:
    # Check for full outer circle rotation followed by inner circle up
    var outer_rotation = _detect_full_rotation(buffer, DualCircleInput.InputCircle.OUTER)
    var inner_up = _detect_direction_in_circle(buffer, Vector2.UP, DualCircleInput.InputCircle.INNER)
    
    return outer_rotation and inner_up and _check_sequence_timing(buffer)

func _detect_full_rotation(buffer: Array[MotionInput], circle: DualCircleInput.InputCircle) -> bool:
    # Implementation for detecting 360° rotation in specified circle
    var rotation_inputs = buffer.filter(func(input): return input.circle == circle)
    return _calculate_total_rotation(rotation_inputs) >= 350.0  # Allow some tolerance
```

### Move Execution System

```gdscript
# Example move execution
func execute_move(move_name: String):
    match move_name:
        "pole_vault":
            _perform_pole_vault()
        "spinning_swipe":
            _perform_spinning_swipe()
        "wall_slide":
            _perform_wall_slide()

func _perform_pole_vault():
    # Arcade-style leap: instant response, fixed distance
    velocity = Vector2(200, -150)  # Forward and up
    _play_animation("pole_vault")
    move_cooldown = 0.2
```

### Enemy AI Patterns

```gdscript
# Base enemy structure
extends CharacterBody2D
class_name BaseEnemy

@export var movement_speed: float = 80.0
@export var health: int = 1

func _ready():
    # Initialize simple AI behavior
    # Set up collision detection
    # Configure destruction conditions

func _physics_process(delta):
    execute_behavior(delta)
    check_player_attacks()
    move_and_slide()

func take_damage():
    health -= 1
    if health <= 0:
        queue_free()
```

## Testing Strategy

### Unit Tests

- **Motion input detection** with various stick patterns
- **Move execution timing** and cooldown systems
- **Enemy behavior** patterns and destruction
- **Cutscene triggering** and training room activation

### Integration Tests

- **Complete room traversal** using specific move combinations
- **Story progression** through cutscenes and training
- **Linear level flow** with proper move unlocking
- **Camera and interaction** system coordination

### Playtesting Scenarios

1. **New Player Experience**: Can someone learn moves from cutscenes?
2. **Motion Input Reliability**: Do stick patterns register consistently?
3. **Difficulty Progression**: Does each room teach before testing?
4. **Controller Compatibility**: Works with Xbox, PlayStation, generic gamepads?
