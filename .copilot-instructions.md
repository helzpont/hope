# AI Development Guidelines for HOPE

## Project Context

You are helping develop HOPE, a 2D puzzle platformer where the player controls a pole-wielding robot using only controller joysticks (no buttons). The game features arcade-style movement with fighting game-inspired motion inputs. This document provides specific guidance for AI assistants working on this project.

## Core Principles

### 1. Stick-Only Input Constraint

- **NEVER** implement button inputs, keyboard controls, or stick clicks
- **ALWAYS** use only left stick for movement/actions and right stick for camera
- **VERIFY** that all interactions can be performed with stick movement only
- **REJECT** any suggestions that require button presses or stick clicks

### 2. Refined Dual-Circle Input Design

- **IMPLEMENT** inverted complexity: inner circle (<90%) = complex, outer circle (>=90%) = simple
- **ADD** hysteresis buffer (85-95% transition zone) to prevent input flickering
- **ENSURE** no simultaneous inputs - only left stick processed for actions
- **PROVIDE** clear visual feedback for circle detection and transitions
- **PRIORITIZE** input responsiveness (<16ms latency) over complex features

### 3. Accessibility Through Design (Non-Controller)

- **PROVIDE** visual feedback for all audio cues
- **ENSURE** colorblind accessibility in all visual elements
- **IMPLEMENT** subtitle support for all audio content
- **DESIGN** generous input windows for complex inner circle patterns
- **AVOID** controller-specific accessibility features (experimental game focus)

### 4. Simplified Development Philosophy

- **FOCUS** on 6-8 core moves maximum (avoid feature creep)
- **USE** tunable parameters instead of fixed values
- **PRIORITIZE** player feel over mathematical precision
- **ITERATE** based on playtesting rather than theoretical design

## Development Approach

### Test-Driven Development

1. **Write tests first** for each new mechanic
2. **Implement minimum viable version** to pass tests
3. **Refactor and polish** while maintaining test coverage
4. **Add integration tests** for dual-circle input combinations

### Code Organization

```
scripts/
├── player/
│   ├── HopeController.gd      # Main player controller
│   ├── DualCircleInput.gd     # Magnitude-based input detection
│   ├── MotionDetector.gd      # Pattern recognition system
│   └── MoveSystem.gd          # Special move execution
├── enemies/
│   ├── BaseEnemy.gd           # Shared enemy behaviors
│   ├── PatrolBot.gd           # Basic enemy type
│   └── SentryBot.gd           # Ranged enemy type
├── environment/
│   ├── MovingPlatform.gd      # Dynamic platforms
│   └── InteractiveSwitch.gd   # Environmental interactions
├── story/
│   ├── CutsceneManager.gd     # Move introduction cutscenes
│   └── TrainingRoom.gd        # Practice areas for new moves
└── systems/
    ├── CameraController.gd    # Right stick camera control
    ├── AudioManager.gd        # Dynamic audio system
    └── GameManager.gd         # Linear progression system
```

### Scene Structure

```
Main.tscn
├── Player/
│   ├── Hope (CharacterBody2D)
│   ├── DualCircleDetector (Node)
│   ├── MotionBuffer (Node)
│   └── MoveAnimator (AnimationPlayer)
├── Environment/
│   ├── StaticGeometry
│   ├── MovingPlatforms
│   └── InteractiveElements
├── Enemies/
│   └── [Enemy instances]
├── Story/
│   ├── CutscenePlayer
│   └── TrainingRoom
├── UI/
│   ├── MoveIndicator
│   └── InteractionPrompts
└── Systems/
    ├── CameraRig
    ├── AudioSources
    └── ProgressionManager
```

## Implementation Guidelines

### Refined Dual-Circle Input System

```gdscript
# Example structure for DualCircleInput.gd
extends Node
class_name DualCircleInput

@export var circle_threshold: float = 0.9  # 90% magnitude threshold
@export var dead_zone: float = 0.1
@export var hysteresis_buffer: float = 0.05  # Hysteresis buffer for input stability

enum InputCircle {
    NONE,
    INNER,    # <90% magnitude - complex moves
    OUTER     # >=90% magnitude - simple moves
}

var current_circle: InputCircle = InputCircle.NONE
var previous_circle: InputCircle = InputCircle.NONE

func process_stick_input(stick_input: Vector2) -> Dictionary:
    var magnitude = stick_input.length()
    var direction = stick_input.normalized()

    var circle = _determine_input_circle(magnitude)
    var is_transition = (circle != previous_circle and circle != InputCircle.NONE)

    previous_circle = current_circle
    current_circle = circle

    var result = {
        "circle": circle,
        "direction": direction,
        "magnitude": magnitude,
        "is_transition": is_transition,
        "complexity_level": _get_complexity_level(circle)
    }

    return result

func _determine_input_circle(magnitude: float) -> InputCircle:
    if magnitude < dead_zone:
        return InputCircle.NONE
    elif magnitude < circle_threshold - hysteresis_buffer:
        return InputCircle.INNER  # Complex moves
    elif magnitude >= circle_threshold:
        return InputCircle.OUTER  # Simple moves
    else:
        return current_circle  # Maintain current circle during hysteresis

func _get_complexity_level(circle: InputCircle) -> String:
    match circle:
        InputCircle.INNER:
            return "complex"  # Requires skill and precision
        InputCircle.OUTER:
            return "simple"   # Basic directional actions
        _:
            return "none"
```

### Player Controller

```gdscript
# Example structure for HopeController.gd
extends CharacterBody2D

@export var move_speed: float = 120.0
@export var sprint_speed: float = 180.0
@export var motion_buffer_time: float = 0.8

var dual_circle_input: DualCircleInput
var motion_detector: MotionDetector
var current_move: String = ""
var move_cooldown: float = 0.0

func _ready():
    dual_circle_input = DualCircleInput.new()
    motion_detector = MotionDetector.new()
    _setup_move_patterns()

func _physics_process(delta):
    handle_left_stick_input()
    handle_right_stick_camera()
    update_motion_detection(delta)
    execute_moves(delta)
    apply_movement(delta)

func handle_left_stick_input():
    var left_stick = Vector2(
        Input.get_joy_axis(0, JOY_AXIS_LEFT_X),
        Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)
    )

    var input_data = dual_circle_input.process_stick_input(left_stick)

    # Handle simple moves (outer circle)
    if input_data.circle == DualCircleInput.InputCircle.OUTER:
        _handle_simple_movement(input_data.direction, input_data.magnitude)

    # Handle complex moves (inner circle)
    elif input_data.circle == DualCircleInput.InputCircle.INNER:
        motion_detector.add_input(input_data.direction, input_data.magnitude)

func handle_right_stick_camera():
    # Camera control only - no clicks allowed
    var right_stick = Vector2(
        Input.get_joy_axis(0, JOY_AXIS_RIGHT_X),
        Input.get_joy_axis(0, JOY_AXIS_RIGHT_Y)
    )

    _update_camera_position(right_stick)

func _handle_simple_movement(direction: Vector2, magnitude: float):
    # Outer circle: simple directional actions
    if direction.length() > 0.1:
        if direction.y < -0.7:  # Up
            _execute_stop()
        elif direction.y > 0.7:  # Down
            _execute_crouch()
        else:  # Horizontal movement
            var speed = sprint_speed if magnitude > 0.95 else move_speed
            velocity = direction * speed
```

### Motion Detection for Complex Moves

```gdscript
# Example motion detection for inner circle patterns
func detect_complex_pattern(buffer: Array[MotionInput]) -> String:
    # Inner circle patterns (complex moves)
    if _matches_inner_pattern(buffer, [Vector2.DOWN, Vector2(1, 1), Vector2.RIGHT]):
        return "pole_vault"

    if _matches_spinning_pattern(buffer):
        return "spinning_swipe"

    if _matches_inner_pattern(buffer, [Vector2.LEFT, Vector2(-1, 1), Vector2.DOWN]):
        return "wall_slide"

    return ""

func _matches_inner_pattern(buffer: Array[MotionInput], pattern: Array[Vector2]) -> bool:
    # Verify all inputs are from inner circle (complex)
    var inner_inputs = buffer.filter(func(input): return input.circle == DualCircleInput.InputCircle.INNER)

    if inner_inputs.size() < pattern.size():
        return false

    # Check pattern matching with tolerance
    return _check_pattern_sequence(inner_inputs, pattern)
```
