# AI Development Guidelines for HOPE

## Project Context
You are helping develop HOPE, a 2D puzzle platformer where the player controls a pole-wielding robot using only controller joysticks (no buttons). The game features arcade-style movement with fighting game-inspired motion inputs. This document provides specific guidance for AI assistants working on this project.

## Core Principles

### 1. Stick-Only Input Constraint
- **NEVER** implement button inputs or keyboard controls
- **ALWAYS** use only left stick, right stick, and right stick click
- **VERIFY** that all interactions can be performed with these inputs
- **REJECT** any suggestions that require additional inputs

### 2. Arcade-Style Design
- **PRIORITIZE** responsive, forgiving controls over realistic simulation
- **IMPLEMENT** motion-based special moves like fighting games
- **ENSURE** player failure feels fair and timing-based
- **AVOID** physics complexity that interferes with gameplay flow

### 3. Accessibility Through Design
- **PROVIDE** visual feedback for all audio cues
- **ENSURE** colorblind accessibility in all visual elements
- **IMPLEMENT** controller rumble for important feedback
- **DESIGN** generous input windows for motion commands

## Development Approach

### Test-Driven Development
1. **Write tests first** for each new mechanic
2. **Implement minimum viable version** to pass tests
3. **Refactor and polish** while maintaining test coverage
4. **Add integration tests** for motion input combinations

### Code Organization
```
scripts/
├── player/
│   ├── HopeController.gd      # Main player controller
│   ├── MotionInput.gd         # Fighting game-style input detection
│   └── MoveSystem.gd          # Special move execution
├── enemies/
│   ├── BaseEnemy.gd           # Shared enemy behaviors
│   ├── PatrolBot.gd           # Basic enemy type
│   └── SentryBot.gd           # Ranged enemy type
├── environment/
│   ├── MovingPlatform.gd      # Dynamic platforms
│   └── InteractiveSwitch.gd   # Environmental interactions
├── story/
│   ├── CutsceneManager.gd     # Move introduction cutscenes
│   └── TrainingRoom.gd        # Practice areas for new moves
└── systems/
    ├── CameraController.gd    # Right stick camera control
    ├── AudioManager.gd        # Dynamic audio system
    └── GameManager.gd         # Linear progression system
```

### Scene Structure
```
Main.tscn
├── Player/
│   ├── Hope (CharacterBody2D)
│   ├── MotionDetector (Node)
│   └── MoveAnimator (AnimationPlayer)
├── Environment/
│   ├── StaticGeometry
│   ├── MovingPlatforms
│   └── InteractiveElements
├── Enemies/
│   └── [Enemy instances]
├── Story/
│   ├── CutscenePlayer
│   └── TrainingRoom
├── UI/
│   ├── MoveIndicator
│   └── InteractionPrompts
└── Systems/
    ├── CameraRig
    ├── AudioSources
    └── ProgressionManager
```

## Implementation Guidelines

### Player Controller

```gdscript
# Example structure for HopeController.gd
extends CharacterBody2D

@export var move_speed: float = 120.0
@export var motion_buffer_time: float = 0.5
@export var input_tolerance: float = 22.5  # degrees

var current_move: String = ""
var motion_buffer: Array[Vector2] = []
var move_cooldown: float = 0.0

func _ready():
    # Initialize motion detection
    # Set up move system
    # Connect to animation player

func _physics_process(delta):
    handle_input()
    update_motion_buffer(delta)
    execute_moves(delta)
    apply_movement(delta)

func handle_input():
    # Left stick: movement and motion input
    # Right stick: camera and interaction
    # Detect motion patterns for special moves
```

### Motion Input System

```gdscript
# Example motion detection
func detect_motion_pattern(buffer: Array[Vector2]) -> String:
    if buffer.size() < 2:
        return ""
    
    # Check for Pole Vault: ↓↘→
    if _matches_pattern(buffer, [Vector2.DOWN, Vector2(1, 1), Vector2.RIGHT]):
        return "pole_vault"
    
    # Check for Spinning Swipe: →↓↘
    if _matches_pattern(buffer, [Vector2.RIGHT, Vector2.DOWN, Vector2(1, 1)]):
        return "spinning_swipe"
    
    return ""

func _matches_pattern(buffer: Array[Vector2], pattern: Array[Vector2]) -> bool:
    # Implementation for pattern matching with tolerance
    # Allow for timing variations and input imprecision
```

### Move Execution System

```gdscript
# Example move execution
func execute_move(move_name: String):
    match move_name:
        "pole_vault":
            _perform_pole_vault()
        "spinning_swipe":
            _perform_spinning_swipe()
        "wall_slide":
            _perform_wall_slide()

func _perform_pole_vault():
    # Arcade-style leap: instant response, fixed distance
    velocity = Vector2(200, -150)  # Forward and up
    _play_animation("pole_vault")
    move_cooldown = 0.2
```

### Enemy AI Patterns

```gdscript
# Base enemy structure
extends CharacterBody2D
class_name BaseEnemy

@export var movement_speed: float = 80.0
@export var health: int = 1

func _ready():
    # Initialize simple AI behavior
    # Set up collision detection
    # Configure destruction conditions

func _physics_process(delta):
    execute_behavior(delta)
    check_player_attacks()
    move_and_slide()

func take_damage():
    health -= 1
    if health <= 0:
        queue_free()
```

## Testing Strategy

### Unit Tests
- **Motion input detection** with various stick patterns
- **Move execution timing** and cooldown systems
- **Enemy behavior** patterns and destruction
- **Cutscene triggering** and training room activation

### Integration Tests
- **Complete room traversal** using specific move combinations
- **Story progression** through cutscenes and training
- **Linear level flow** with proper move unlocking
- **Camera and interaction** system coordination

### Playtesting Scenarios
1. **New Player Experience**: Can someone learn moves from cutscenes?
2. **Motion Input Reliability**: Do stick patterns register consistently?
3. **Difficulty Progression**: Does each room teach before testing?
4. **Controller Compatibility**: Works with Xbox, PlayStation, generic gamepads?
